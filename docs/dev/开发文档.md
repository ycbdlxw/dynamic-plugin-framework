# 项目开发宪法与开发者指南

本指南是项目所有开发活动的最高准则。所有开发者，包括AI助手，都必须严格遵守本文档中定义的架构哲学、开发规范和协作流程。

## 核心哲学 ("The Constitution")

1. **数据驱动一切**: 这是我们最核心的原则。任何业务逻辑、校验规则、API行为，都必须优先通过查询配置表（如 `table_attribute`, `column_attribute`, `column_check_property`）来驱动。**在编写Java代码前，必须首先思考："这个功能能否通过修改数据库配置来实现？"**
2. **配置优于编码**: 如果一个功能可以通过增加一条数据库配置记录来完成，就绝不应该硬编码在Java代码中。
3. **插件化一切**: 任何独立的、大型的业务功能（如文件服务、AI服务），都必须实现为可独立加载、卸载的插件。插件应封装自己的Controller、Service，并通过 `IPlugin`接口与核心引擎交互。
4. **"三不三少"原则**:
   * **三不**: 不过度开发、不过度复杂、不破坏现有功能。
   * **三少**: 少文件、少代码、少调用。始终追求最简洁、最高效的实现。

## 架构设计

1. **双引擎架构**:
   - **数据引擎**: 由 `CommonService`, `BaseService`, `SystemMapper`及相关配置表构成，负责所有通用数据操作。
   - **插件引擎**: 由 `PluginEngine`, `IPlugin`接口及 `plugin_config`表构成，负责动态功能的生命周期管理。
2. **三层架构**: 严格遵守 **表现层(Controller)** -> **业务层(Service)** -> **数据访问层(Mapper)** 的分层结构。
3. **安全层**: `AuthenticationAspect`作为安全切面，对所有进入Controller的请求进行统一的JWT校验和用户上下文设置。

## 开发规范

### 命名规范

- **包名（package）**：全部小写，使用反转域名的层次结构。如：`com.ycbd.demo`。子包按功能或层级细分，不使用拼音。
- **类名（Class）**：使用 PascalCase，以名词或名词短语命名，如 `UserService`、`PluginEngine`。抽象类可加前缀 `Abstract`，如 `AbstractProcessor`。
- **接口（Interface）**：使用 PascalCase，必要时以功能+`Service`/`Repository` 结尾。若需突出接口特性，可使用 `I` 前缀，如 `IPlugin`。
- **方法名（Method）**：使用 camelCase，以动词开头，表达动作和意图，如 `saveUser()`、`buildQuery()`。
- **变量名（Variable）**：使用 camelCase，以名词或名词短语命名，避免缩写，如 `userName`、`queryRuleList`。
- **常量（Constant）**：使用 `UPPER_SNAKE_CASE`，需加 `static final` 修饰，如 `MAX_RETRY_COUNT`。
- **数据库表名**：使用 `snake_case`，尽量为复数形式，如 `user_accounts`。中间表使用 `xxx_relation` 或 `xxx_mapping`。
- **数据库字段名**：使用 `snake_case`，简洁明了，如 `created_at`、`user_id`。
- **XML/Mapper SQL 别名**：使用 `snake_case`，与字段名保持一致，避免歧义。
- **脚本与资源文件**：文件名使用 `kebab-case` 或 `snake_case`，表达内容含义，如 `run_all_tests.sh`、`application-test.properties`。
- **测试用例**：类名以被测类名 + `Test` 结尾，如 `PluginEngineTest`。方法名以 `should` 开头描述行为，如 `shouldLoadPluginSuccessfully()`。
- **枚举值**：使用 `UPPER_SNAKE_CASE`，如 `SUCCESS`, `FAILURE`。

> 遵循统一的命名规则可以显著提升代码可读性、可维护性，并降低团队协作成本。如遇特殊场景无法满足以上规则，应在代码注释中说明原因。

### API设计

- **RESTful风格**: 使用标准的HTTP方法 (GET, POST, PUT, DELETE)。
- **统一响应**: 所有Controller接口必须返回 `ApiResponse`对象，以确保前端接收到统一的 `{code, message, data}` 格式。
- **统一入口**: 通用CRUD操作应通过 `/api/common`下的接口进行。插件提供的功能性API应有自己的命名空间，如 `/api/plugins/upload`。

### 安全与认证

- **JWT认证**: 所有非白名单接口都必须在请求头中携带 `Authorization: Bearer <token>`。
- **用户信息获取**: 在业务逻辑中，**严禁**从前端参数获取用户信息。必须通过 `UserContext.getUserId()`或 `UserContext.getUserName()`从安全上下文中获取。
- **白名单配置**: API的访问白名单由 `security_config`表动态管理。

### 数据库交互

- **禁止裸写SQL**: 严禁在Java代码（尤其是Service层）中拼接SQL语句。
- **使用Mapper**: 所有数据库操作必须通过 `SystemMapper`接口及其对应的XML文件完成。
- **配置驱动**: 表的CRUD行为（如可编辑字段、列表显示字段、排序规则）由 `table_attribute`和 `column_attribute`表定义。
- **校验规则**: 数据的业务校验逻辑由 `column_check_property`表定义，并通过 `ValidationService`统一执行。

### 插件开发

1. **创建主类**: 实现 `IPlugin`接口。
2. **封装组件**: 将插件所需的Controller、Service等组件放在独立的包内，且**不能**有 `@Service`, `@RestController`等Spring启动时注解。
3. **生命周期管理**:
   - 在 `initialize()`方法中，使用 `BeanDefinitionRegistry`动态注册插件内部的Bean，并刷新 `RequestMappingHandlerMapping`以激活Controller。
   - 在 `shutdown()`方法中，执行相反的操作，注销Bean并清理资源。
4. **依赖核心服务**: 插件可以通过 `@Autowired`注入核心平台提供的任何Bean（如 `CommonService`, `BaseService`）。依赖由 `PluginEngine`在加载时自动注入。
5. **打包与部署**: 将编译后的所有 `.class`文件（保持包结构）放入服务器的 `plugins/`目录下。

### 异常处理

- **向上抛出**: 业务逻辑中的异常应直接向上抛出，或包装为自定义的业务异常。
- **全局捕获**: `GlobalExceptionHandler`会捕获所有未处理的异常，并返回统一的错误响应格式。

## 通用字典表 `sys_dictionary`

| 字段                    | 说明          | 示例               |
| ----------------------- | ------------- | ------------------ |
| id                      | 主键          | 1                  |
| dict_name               | 字典名称/类型 | camera_model_dict  |
| keyword                 | 关键字        | IMG_ / DCIM        |
| category                | 标签/值       | Apple / Canon      |
| extra                   | JSON 扩展     | {"model":"iPhone"} |
| created_at / updated_at | 时间戳        |                    |

使用规范：

1. **新增或维护** 通过 `/api/common/save` 接口写入，遵守同一个 dict 下 `keyword` 唯一性。
2. **查询** 使用 `dict_name` + `keyword` 过滤。
3. **字典驱动**：
   - `DescriptionBasedClassifier` 读取 `image_keyword_map` 进行描述分类。
   - `MetadataProcessor` 读取 `camera_model_dict`、`metadata_field_dict` 做品牌解析和 EXIF 映射。
4. 后续如需多租户扩展，添加 `owner_type/owner_id` 字段并依优先级查询。
